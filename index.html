

<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Flappy Bird</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(180deg, #4dc9e6 0%, #87ceeb 100%);
      font-family: 'Arial', sans-serif;
      overflow: hidden;
      touch-action: manipulation;
    }
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      max-width: 480px;
      max-height: 800px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.5);
      color: white;
      text-align: center;
      padding: 20px;
    }
    #gameOverScreen {
      display: none;
    }
    h1 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      text-shadow: 3px 3px 0 #000;
      color: #fff700;
    }
    .score-display {
      font-size: 1.8rem;
      margin: 10px 0;
    }
    .instruction {
      font-size: 1.2rem;
      margin-top: 30px;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    #currentScore {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 3rem;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
      z-index: 10;
      display: none;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>
    <div id="currentScore">0</div>

```
<div id="startScreen">
  <h1>üê¶ Flappy Bird</h1>
  <p class="instruction">Tap to Start & Fly</p>
</div>

<div id="gameOverScreen">
  <h1>Game Over</h1>
  <p class="score-display">Score: <span id="finalScore">0</span></p>
  <p class="score-display">Best: <span id="bestScore">0</span></p>
  <p class="instruction">Tap to Play Again</p>
</div>
```

  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('gameContainer');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const currentScoreEl = document.getElementById('currentScore');
    const finalScoreEl = document.getElementById('finalScore');
    const bestScoreEl = document.getElementById('bestScore');

    function resizeCanvas() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    let gameState = 'start';
    let score = 0;
    let bestScore = localStorage.getItem('flappyBest') || 0;
    bestScoreEl.textContent = bestScore;

    const bird = {
      x: 0, y: 0,
      width: 40, height: 30,
      velocity: 0,
      gravity: 0.6,
      jumpStrength: -10,
      rotation: 0,
      // Wing flap system
      wingAngle: 0.5,
      flapTimer: 0,
      isFlapping: false
    };

    let pipes = [];
    const pipeWidth = 70;
    const pipeGapStart = 180;
    const pipeGapMin = 100;
    let pipeSpeed = 3;
    let pipeSpawnTimer = 0;
    const pipeSpawnInterval = 90;
    const groundHeight = 80;
    let groundX = 0;

    function resetGame() {
      bird.x = canvas.width * 0.25;
      bird.y = canvas.height * 0.4;
      bird.velocity = 0;
      bird.rotation = 0;
      bird.wingAngle = 0.5;
      bird.flapTimer = 0;
      bird.isFlapping = false;
      pipes = [];
      score = 0;
      pipeSpawnTimer = 0;
      lastPipeCenter = null;
      currentScoreEl.textContent = '0';
    }

    function triggerFlap() {
      bird.wingAngle = -1;
      bird.isFlapping = true;
      bird.flapTimer = 0;
    }

    function jump() {
      if (gameState === 'start') {
        gameState = 'playing';
        startScreen.style.display = 'none';
        currentScoreEl.style.display = 'block';
        resetGame();
        bird.velocity = bird.jumpStrength;
        triggerFlap();
      } else if (gameState === 'playing') {
        bird.velocity = bird.jumpStrength;
        triggerFlap();
      } else if (gameState === 'gameOver') {
        gameState = 'playing';
        gameOverScreen.style.display = 'none';
        currentScoreEl.style.display = 'block';
        resetGame();
      }
    }

    document.addEventListener('touchstart', (e) => {
      e.preventDefault();
      jump();
    }, { passive: false });
    document.addEventListener('mousedown', jump);
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') jump();
    });

    function getCurrentGap() {
      if (score <= 10) return pipeGapStart;
      if (score >= 20) return pipeGapStart - (20 - 10) * 4; // Frozen at score 20 value
      const reduction = (score - 10) * 4;
      return pipeGapStart - reduction;
    }

    let lastPipeCenter = null; // Track last pipe center for spread mechanic

    function spawnPipe() {
      const currentGap = getCurrentGap();
      const minHeight = 80;
      const maxHeight = canvas.height - groundHeight - currentGap - minHeight;
      
      let topHeight;

      // Score 20-30+: gradually force pipes to alternate high/low
      if (score >= 20 && lastPipeCenter !== null) {
        // Spread factor: 0 at score 20, 1.0 at score 30+
        const spreadFactor = Math.min((score - 20) / 10, 1.0);
        
        const midZone = (minHeight + maxHeight) / 2;
        const range = maxHeight - minHeight;
        
        // If last pipe was above center, push this one low (and vice versa)
        if (lastPipeCenter < midZone) {
          // Last was high ‚Üí push low
          const lowMin = midZone + (range * 0.2 * spreadFactor);
          const lowMax = maxHeight;
          topHeight = Math.random() * (lowMax - lowMin) + lowMin;
        } else {
          // Last was low ‚Üí push high
          const highMin = minHeight;
          const highMax = midZone - (range * 0.2 * spreadFactor);
          topHeight = Math.random() * (highMax - highMin) + highMin;
        }
        
        // Clamp to valid range
        topHeight = Math.max(minHeight, Math.min(maxHeight, topHeight));
      } else {
        topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
      }
      
      lastPipeCenter = topHeight + currentGap / 2;
      
      pipes.push({
        x: canvas.width,
        topHeight: topHeight,
        bottomY: topHeight + currentGap,
        passed: false
      });
    }

    function update() {
      if (gameState !== 'playing') return;

      bird.velocity += bird.gravity;
      bird.y += bird.velocity;
      bird.rotation = Math.min(Math.max(bird.velocity * 3, -30), 90);

      // Wing animation
      if (bird.isFlapping) {
        bird.flapTimer++;
        if (bird.flapTimer < 4) {
          bird.wingAngle = -1;         // Wings UP
        } else if (bird.flapTimer < 7) {
          bird.wingAngle = -0.3;       // Coming down
        } else if (bird.flapTimer < 10) {
          bird.wingAngle = 0.8;        // Power downstroke
        } else if (bird.flapTimer < 14) {
          bird.wingAngle = 0.4;        // Settling
        } else {
          bird.isFlapping = false;
        }
      } else {
        // Gentle idle float
        bird.wingAngle = 0.5 + Math.sin(Date.now() / 200) * 0.15;
      }

      pipeSpawnTimer++;
      if (pipeSpawnTimer >= pipeSpawnInterval) {
        spawnPipe();
        pipeSpawnTimer = 0;
      }

      for (let i = pipes.length - 1; i >= 0; i--) {
        pipes[i].x -= pipeSpeed;
        if (!pipes[i].passed && pipes[i].x + pipeWidth < bird.x) {
          pipes[i].passed = true;
          score++;
          currentScoreEl.textContent = score;
        }
        if (pipes[i].x + pipeWidth < 0) pipes.splice(i, 1);
      }

      groundX -= pipeSpeed;
      if (groundX <= -50) groundX = 0;

      checkCollisions();
    }

    function checkCollisions() {
      if (bird.y + bird.height > canvas.height - groundHeight || bird.y < 0) {
        gameOver();
        return;
      }
      for (const pipe of pipes) {
        if (bird.x + bird.width - 10 > pipe.x && bird.x + 10 < pipe.x + pipeWidth) {
          if (bird.y + 5 < pipe.topHeight || bird.y + bird.height - 5 > pipe.bottomY) {
            gameOver();
            return;
          }
        }
      }
    }

    function gameOver() {
      gameState = 'gameOver';
      currentScoreEl.style.display = 'none';
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('flappyBest', bestScore);
      }
      finalScoreEl.textContent = score;
      bestScoreEl.textContent = bestScore;
      gameOverScreen.style.display = 'flex';
    }

    function draw() {
      // Sky
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#4dc9e6');
      gradient.addColorStop(1, '#87ceeb');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Clouds
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      drawCloud(50, 80, 60);
      drawCloud(200, 150, 45);
      drawCloud(320, 60, 55);

      // Pipes
      for (const pipe of pipes) {
        ctx.fillStyle = '#73bf2e';
        ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
        ctx.fillStyle = '#5a9a23';
        ctx.fillRect(pipe.x - 5, pipe.topHeight - 30, pipeWidth + 10, 30);
        ctx.fillStyle = '#73bf2e';
        ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY - groundHeight);
        ctx.fillStyle = '#5a9a23';
        ctx.fillRect(pipe.x - 5, pipe.bottomY, pipeWidth + 10, 30);
      }

      // Ground
      ctx.fillStyle = '#ded895';
      ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
      ctx.fillStyle = '#5cb85c';
      ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 20);

      // ===== BIRD WITH WING FLAP =====
      ctx.save();
      ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
      ctx.rotate(bird.rotation * Math.PI / 180);

      const wingRotation = bird.wingAngle * 0.8;

      // Right wing (behind body)
      ctx.save();
      ctx.translate(-2, -1);
      ctx.rotate(wingRotation * 0.8);
      ctx.fillStyle = '#daa520';
      ctx.beginPath();
      ctx.ellipse(-5, -2, 18, 9, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Body
      ctx.fillStyle = '#f7dc6f';
      ctx.beginPath();
      ctx.ellipse(0, 0, bird.width / 2, bird.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#d4ac0d';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Left wing (in front) - animated
      ctx.save();
      ctx.translate(-5, 2);
      ctx.rotate(wingRotation);
      
      ctx.fillStyle = '#f0b429';
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 11, -0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#d4a017';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Feather lines
      ctx.strokeStyle = 'rgba(180, 130, 20, 0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-6, -3);
      ctx.lineTo(-16, 0);
      ctx.moveTo(-4, 2);
      ctx.lineTo(-14, 5);
      ctx.moveTo(-2, 7);
      ctx.lineTo(-12, 10);
      ctx.stroke();
      ctx.restore();

      // Eye
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.ellipse(10, -6, 9, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(13, -5, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(14, -7, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Beak
      ctx.fillStyle = '#e74c3c';
      ctx.beginPath();
      ctx.moveTo(16, 1);
      ctx.lineTo(30, 5);
      ctx.lineTo(16, 9);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#d35400';
      ctx.beginPath();
      ctx.moveTo(16, 5);
      ctx.lineTo(26, 6);
      ctx.lineTo(16, 9);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawCloud(x, y, size) {
      ctx.beginPath();
      ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
      ctx.arc(x + size * 0.4, y - size * 0.2, size * 0.4, 0, Math.PI * 2);
      ctx.arc(x + size * 0.8, y, size * 0.45, 0, Math.PI * 2);
      ctx.fill();
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    resetGame();
    gameLoop();
  </script>

</body>
</html>
